ISILEX, un serveur REST et gestionnaire de contenus collaboratifs au format XML au service des Humanités Numériques
Xavier-Laurent Salvador - CERAL – EA 3968, DIM Sciences du Texte et connaissances nouvelles

Résumé: Digital Literacies offer a new and comprehensive Way for thinking and building new Objects of Science cross linking new Datas Building Tools and, most of all, Text Ressources. Isilex (http://www.isilex.fr) is an XML CMS server based upon Web Rest Philosophy and Full-Text XQuery oriented. It allows easy and new Issues for Immediate Corpus Publication.
Résumé: Dans le contexte des Humanités Numériques, il est désormais possible de développer de nouveaux moyens de représentations des données textuelles affranchies de la logique documentaire. Isilex (http://www.isilex.fr) est un gestionnaire de contenus XML en même temps qu’un serveur Web basé sur la philosophie innovante du Web intitulée REST et basée sur les possibilités de programmation offertes par la bibliothèque Full-Text d’XQuery. Il permet de penser de nouveaux moyens pour la mise en ligne immédiate d’encyclopédies et de corpus.

Penser le corpus du texte biblique médiéval, c’est être amené à penser la polyphonie. Les moyens d’édition hérités de la modernité ne permettent pas d’exploiter le codex pour représenter la richesse du travail de l’auteur médiéval. Dans la Bible historiale par exemple, les références bibliques sont croisées, comme j’ai pu le démontrer ailleurs (SALVADOR (2), 2017), avec les commentaires des exégètes aussi bien qu’avec des interventions personnelles de la main du traducteur. A partir du moment où il y a traduction, ou plutôt transvasement du sacré d’un coffre à un autre, l’opération s’accompagne d’un sentiment de déperdition informative qui est l’image linguistique d’une impression de corruption de l’originalité de la parole divine. Ce sentiment entraîne, pour le traducteur, le besoin de compenser cette dépréciation de l’objet par un ensemble de procédés qui ont pour but de valider l’authenticité du texte. La conjonction de l’Histoire Scolastique et de la Vulgate en est le moyen le plus flagrant. Un autre moyen tout aussi frappant est l’apparition d’une autorité insérée dans le corps même de l’ouvrage, comme on peut en trouver un exemple en Gn. 24,10: 
Donc prist il .x. chamaux du fouc son Seigneur si s’en ala et porta avec lui de tous les biens son Seigneur mesmement de ceulx qu’il savoit qu’il y avoit peu en la terre ou il aloit ce dist le maître en histoires si s’en ala en Mesopotarmie a Charan la cité Nachor. Cy dist Josephus qu’il vint a grant travail et grant temps mist car il y a la parfondes ces en yver et en ete grant faulte d’yaue et es landes grant plantes de larrons.
On voit bien comment le texte de la Bible Historiale se donne comme un discours polyphonique, les autorités intervenant dans le texte permettant de désigner l’ouvrage français comme étant fidèle au discours authentique. Les exemples sont très nombreux et je les ai largement documentés. Les moyens de penser un corpus comme celui de la Bible Historiale amènent tout naturellement à s’orienter vers des pistes de représentations du texte qui incluent, en amont, la possiblilité d’un travail pérenne pour une équipe sur le long terme et en aval, la possibilité de consulter le texte, ses références, ses variations, ses traductions dans toutes les langues afin de permettre à un moteur de recherches de cibler la donnée et d’en extraire la clé interprétative de manière semi automatique sous la forme d’une synopse. 
C’est dans ce contexte que nous avons proposé le développement d’un outil de se saisie et de mise en ligne de corpus automatisés (http://www.isilex.fr). Les choix théoriques qui ont présidé au développement d’Isilex sont intimement liés au développement des humanités numériques. Il faut orienter les bases de données vers les problématiques de la science du texte et de la connaissance nouvelle (http://www.humanitesnumeriques.fr), c’est pourquoi nous avons fait le choix de travailler dans un univers qui accorde toute sa valeur à la profondeur de la donnée dans le contexte de Small Datas. Le choix s’est naturellement porté sur des options technologiques qui accordent leur place à l’innovation.
REST

Nous avons privilégié une philosophie Web, largement exploitée, dénommée REST qui rompt avec la représentation de l’URL comme dénomination du document sauvé pour une évaluation de l’URL comme « lieu de la donnée » (SALVADOR (1), 2017) clairement pointé. Comme Alexandre Monnin (2014), nous concluons qu’au souci posé par l’instabilité de l’actualisation des URI soulevé par Tim Berners-Lee (1998):
…the solution advocated in REST (in a nutshell, without exhausting REST’s signicance for the Web) is a very elegant one. It states that instead of files, documents, objects, and so forth, what is being referred to by a URI is a “resource.” Here’s the de nition given in REST (by Fielding and Taylor): “A resource R is a temporally varying membership function MR(t), which for time t maps to a set of entities, or values, which are equivalent. The values in the set may be resource representations and/ or resource identi ers. A resource can map to the empty set, which allows references to be made to a concept before any realization of that concept exists—notion that was foreign to most hypertext systems prior to the Web” (Fielding and Taylor 2002, 125)
L’idée est que le serveur logiciel, plutôt que d’être lie à un stockage permanent dont il subit l’administration des droits d’écriture, évalue chaque URL comme le déclencheur d’un algorithme. A chaque invocation d’une URL dans le navigateur, on associe non pas un document, mais une fonction logicielle développée dans un langage pré-déterminé. Cette option, développée par Roy Fielding dans sa thèse (Fielding, 2008) est assez innovante en libérant le serveur des contraintes qui liaient la consultation d’une collection de données aux logiciels serveurs. Avec le développement de la logique REST, l’URL cible potentiellement un grand réservoir de représentations de données formées grâce à l’URL elle-même, et non pas consultées grâce à l’URL. Cette différence majeure entre la représentation de la donnée et sa formation offre une puissance non négligeable au chercheur en sciences du texte(s) puisque le formant, l’URL, permet de faire du client Web un co-constructeur de la ressource qu’il consulte. L’oeuvre n’est donc plus pensée en amont par un auteur ou un concepteur-éditeur, mais elle est retaillée immédiatement au prisme du regard que le lecteur pose sur elle. Dans le cas qui nous préoccupe particulièrement, à savoir la Bible historiale, la question n’est donc plus de penser la Bible en ancien français, ou en latin, ou en grec avec des liens vers ses commentaires, mais plutôt de construire un réservoir de données en base qui offre au lecteur la possibilité de construire la synopse et le lien qu’il désire, le site étant un atelier au sein duquel se déploie l’imagination créatrice du chercheur. Ce faisant, on abolit l’obstacle constitué par la maîtrise de l’outil en favorisant le développement de la ressource.
L’orientation vers des bases de données entièrement débarrassée de SQL est naturelle dans les sciences du Texte dans la mesure où XML s’est depuis longtemps imposé comme un standard de la représentation des lieux de donnés (SALVADOR, 2016), même si parfois c’est pour de mauvaises raisons. Les bases de données non relationnelles en effet sont adaptées à la représentation des données textuelles parce que leur mode d’indexation offre une prise en compte de la variabilité des degrés de profondeur que ne permettent pas les logiques tabulaires et matricielles des bases de données relationnelles. Autrement dit, dans la mesure où il n’est jamais possible de prédire le degré de diffusion de données dans un texte (on ne peut pas rapporter un texte à un nombre préconstruit de champ qu’il faudrait remplir), la logique des MarkUp languages, au premier rang desquels XML, offre un mode de représentation certes bavard mais efficace. A cela s’ajoute que l’objectif de toute base de données en Humanités Numériques s’orientant vers l’édition numérique, soit sur le Web soit sous des formats standardisés du monde de l’édition conformes aux préconisations du W3C (epub & HTML ou XHTML, docx(ml)), il semble naturel de s’orienter vers un serveur de bases de données comme Basex, développé par l’équipe de Christian Gruën à l’Université de Konstanz (http://www.basex.org) qui permet d’adosser très solidement des bases de données au format XML indexées à des applications Web obéissant au modèle de philosophie REST.
C’est donc pour répondre à cette double contrainte: la publication du texte de la Bible Historiale et la mise en ligne de données en Sciences du Texte qu’est né le gestionnaire de contenu et serveur de bases de données Isilex (http://www.isilex.fr).
XML

Le formalisme XML parfaitement documenté à travers les préconisations du W3C nous semble particulièrement adapté au projet que nous venons de décrire. De quoi s'agit-il concrètement ? Il est nécessaire de se représenter le texte informatique et sa manifestation comme une succession de couches progressives d'abstraction. 
Le caractère à ce titre, le caractère informatique, constitue le premier degré d'abstraction. « La matière du document, l’octet qui le compose (chaque petite case du tableau de gauche), est ici représentée sous sa forme hexadécimale. Le tout est un flux qui se représente sous forme d’un texte, encodé, signé de sa police (SALVADOR, 2016 p. 13)». Le fichier numérique matérialisant les données saisies par un opérateur qui présente la compétence linguistique nécessaire au déchiffrage d'un manuscrit est un premier degré d'abstraction de la réalité matérielle et surtout, recueille pour la première fois une chose essentielle dans la perspective informatique : des données. Tout fichier texte programme de manière simple un ensemble de données liées au projet initial de restitution des connaissances historiques. Le choix de la nature de l'encodage du caractère qui va informer les données va conditionner toute la nature du corpus. Ainsi, le choix d'UTF-8 s'impose-t-il au linguiste pour le degré élevé de précision qu'il autorise dans la description de la combinaison des caractères de toutes les langues (c'est son lien avec  unicode).
Le deuxième degré d'abstraction consiste à penser l'organisation de la donnée. C'est à ce niveau qu'intervient le formalisme XML et tous les conventionnements qui en découlent (RDF, OWL, SKOS (SALVADOR, 2016 p. 78)) qui reposent sur une convention typographique extrêmement simple mais très puissante : inscrire entre chevrons ce qui concerne les données, en dehors des chevrons ce qui relève de la donnée. De cette dernière proposition découle que les informations de structure entre chevrons relèvent d'une économie de la parenthèse : à un bloc entre chevrons ouvrant (<a>) correspond un bloc fermant (</a>). Considérons qu'une ligne du texte de la Bible soit une donnée: le formalisme XML permet d'instruire dans le fil du texte lui-même une méta information dans le corps du texte : <verset>abcde</verset>. Ici, « abcde » est une donnée (le texte lui-même) et le balisage structure cette donnée en fonction d'une information discrète pertinente pour le lecteur : c'est un « verset ». Le sémantique du nom de la balise n’est signifiant que pour le lecteur humain; toutefois, au regard de la machine, il n’est pas indifférent que cet extrait de texte soit nommé: la balise devient un niveau hiérarchique de l’information. 
La nature particulière de cette structure balisée permet de distinguer ce qui relève de la classe d'information (ici « verset ») des spécifications portées par des attributs. En l'occurrence, une structure similaire pourrait être illustrée par l’exemple suivant où l’attribut sémantiquement signifiant pour le lecteur « nature = ‘glose’ » caractérise un sous ensemble de la classe « verset » en apportant deux informations liées, à savoir qu’il existe un attribut de la classe « verset » qui se nomme « nature » et que cette « nature » peut prendre au moins une valeur, en l’occurrence « glose » : 
<verset nature=‘glose'>abcde</nature>
Le troisième degré d'abstraction est impliqué par la structure imbriquée des blocs de balisage. De même qu'une parenthèse doit être fermée avant qu'une autre ne s'ouvre, des blocs marqués entre des balises sont systématiquement inclus les uns dans les autres. 
Il est juste d'écrire :
	<Bible> 	 <paragraphe>         <titre> </titre>         <texte> </texte>        </paragraphe>       </Bible>
Il est faux d'écrire : 
	*<Bible>         <paragraphe>         <titre> </titre>       *</Bible>         </paragraphe>
De cette structure imbriquée naît l'idée que tout bloc de texte est en fait une structure hiérarchiquement organisée dans le temps, à savoir une généalogie. Dans l'exemple précédent, il est admis de décrire chacun des blocs en termes de filiation et de fraternité : <paragraphe/> est fils de <Bible/>, <titre/> et <texte/> sont frères. Dans le déroulement de cette généalogie, chacun des noms de balise constitue un nœud d'embranchement tandis que l'axe selon lequel se déroule la filiation constitue une branche.
Reste finalement que l'extrême avantage du formalisme XML demeure également son point faible : le caractère laxiste de la description des métadonnées ouvre la porte à de multiples interprétations de la part des opérateurs de saisie – ce qui peut aboutir très vite à une forme d’anarchie dans le choix des lexiques déterminants les classes et les spécifications. Il est extrêmement avantageux de pouvoir exercer une contrainte sur la structure d'une base de données en décrivant dans un document annexe la fiche prototypique à laquelle toute saisie successive doit obéir de manière à uniformiser le formalisme. On touche là un quatrième degré d'abstraction matérialisée par un document texte secondaire qui est lié à tout document XML et qui en décrit le contenu soit en respectant une syntaxe propre (DTD) soit en suivant le fonctionnement d’un méta-schéma XML: XSD. Enfin, au sommet de cet empilage de normes d’encodage de l’information, se trouvent placées les propositions de normalisation et de dénomination des lieux de données en fonction d’objectifs communs, comme l’édition en ligne par exemple, qui s’est dotée, avec la TEI, d’un lexique commun de représentation numérique du codex. Ce jeu de convention, qui n’a aucune efficacité sur la représentation de l’objet en ligne par exemple, est en revanche un excellent moyen opératoire  pour le transfert et le partage de connaissances. 
La structuration généalogique de l'information pose la question toutefois de l'adressage de l'information et de son accessibilité. Par adressage, nous renvoyons à tous les moyens de conventions qui identifient des lieux dans une chaîne textuelle (on peut penser aux coordonnées d’un tableau, aux offsets d’une chaîne binaire, aux balises d’un formalisme XML, aux conventions XPath). Prenons par exemple un texte structuré de la manière suivante :
1.	<Bible> 2.	 <paragraphe type='Bible'> 3.	  <ref> 4.	   <chapitre n='1'/> 5.	   <verset n='1'/> 6.	  </ref> 7.	   Et Dieu dist :  8.	 </paragraphe> 9.	 <paragraphe id='glose'>Josephust dist que [...]</paragraphe> 10. </Bible>
On distingue ici un bloc hiérarchiquement le plus élevé (l.2 à 8: « Bible ») qui est en quelque sorte la racine de l'arborescence. On constate qu'il existe deux natures de paragraphes (« Bible » et « glose » l.9), un bloc de référence (l.3 à l.6 « ref ») qui comporte une référence de chapitre et une référence de verset. Si la numérotation est pertinente pour le regard du lecteur humain, elle est insignifiante dans le contexte de l’indexation d’une base de données où la structure linéaire est fragmentée pour être recomposée ensuite. Il faut donc pouvoir nommer précisément l'adresse où se trouve la référence du chapitre concerné, adresse qui serait la même à chaque fois pour tout verset indépendamment du contexte du paragraphe. Ici la donnée relève de l'affectation de l'attribut (« n = 1 ») ou de l'affectation de la valeur du bloc instruit par XML. Pour naviguer dans une  telle généalogie, on recourt à un système conventionnel nommé « Xpath » qui reprend les modèles symboliques de la structuration des archives documentaires pour désigner le lieu au coeur de la donnée. Un noeud est donc symbolisé par le symbole shlash et la branche est figurée par son nom jusqu'à la feuille qui contient la donnée décrite. L'attribut est décrit entre crochets et précédé du symbole 'a commercial' (@). Il existe un ensemble d’abréviations symboliques qui sont autant de jokers. En l'occurrence, la référence de tous les versets du paragraphe biblique est décrite :
	/Bible/paragraphe/ref/verset/@n
En l'occurrence, précisément, l'expression ci-dessus cible l'adresse de tous les numéros de versets d'un corpus. XPath intègre également un ensemble de fonctions de spécifications qui s’insèrent entre crochets. Le numéro du verset « Et Dieu dist » s'écrit :
	/Bible/paragraphe[.='Et Dieu dist']/ref/verset/@n
Xpath permet donc de manière statique de décrire précisément l'adresse des données.
XQUERY
Tout ce que nous venons de décrire rend parfaitement compte des quatre degrés d'abstraction qui caractérisent l'élaboration d'un fichier de données informé selon un protocole, XML.
–	l'encodage du document et la façon dont on s'accorde pour la représentation des caractères dans un fichier numérique
–	le formalisme mis en œuvre pour la structuration des données
–	L'acquisition d'un protocole conventionnel pour la métadescription des données (DTD/XSD)
–	L'acquisition d'un protocole descriptif de l'adressage des données dans une généaologie de type XML
Toutefois, tout cela ne répond pas à l'exigence dynamique qui préside au choix d'XML pour l'édition d'un texte médiéval par exemple. En effet, Xpath comme d'ailleurs le document XML sont des blocs statiques qu'il est satisfaisant de pouvoir décrire de manière abstraite mais que l'on ne peut pas à ce stade interroger et encore moins transformer au gré des requêtes d'un lecteur. Imaginons par exemple que les besoins de la recherche impliquent de réduire au vol toute l'édition du livre de la Genèse de Guyart des Moulins à la partie uniquement traduite de Pierre le Mangeur, ou au contraire de ne retenir que la partie traduite de la Vulgate. Comment faire ? Il est alors nécessaire de franchir un degré supplémentaire dans l'abstraction pour quitter le stade du document numérique descriptif et entrer de plain pied dans le monde de la base de données et des langages de transformation. 
Le gestionnaire de bases de données est un logiciel qui partant d'un document de type texte structuré au format XML en fonction des contraintes exercées par la DTD ou l’XSD compile l'ensemble des données pour en extraire une série d'index qui rendent rapides la consultation des feuilles de l'arborescence pour des textes numériques très volumineux. Ces logiciels d'indexation sont souvent performants, multi plate-formes et rendent exploitables des corpus croisés. Toutefois, pour pouvoir les exploiter, il faut s'accorder encore sur un formalisme de transformation : partant d'un objectif donné, décrit précisément grâce aux formules d'adressage Xpath, comment réduire et reformuler la base initiale du texte de la Bible tel qu'il a été saisi en un autre frgment XML adapté à la réponse trouvée ? La réponse est apportée par les préconisations du W3C en matière de programmation XQuery.
Une requête Xquery se construit selon une syntaxe simple : la boucle. Il est possible de déclarer un nombre infini de boucles successives parcourant une arborescence et d'affecter à une série de variables le résultat joint de ces parcours triés en fonction d'un champ donné. Par « champ », j'entends ici le nom spécifique d'un bloc XML. Pour reprendre l'exemple précédent Xpath, disons que la questions suivante : « Quel est le numéro du verset qui commence par « Et Dieu dist » s'écrirait ainsi :
for $verset  	in /Bible/paragraphe[starts-with(.,'Et Dieu dist')]/ref/verset/@n 		   return $verset
Xquery est en fait un langage de programmation de haut niveau composé de cinq instructions de base, une syntaxe Xpath et une bibliothèque étendue de fonctions. Il est admis généralement que les cinq instructions sont regroupées sous l'acronyme « FLWOR », pour « For, Let, Where, Order, Return ». Concrètement, « For » et « Let » sont les deux instructions de déclaration de variables. L'exemple précédent pourrait être écrit de nouveau :
1. Let $verset :=  2.     /Bible/paragraphe[starts-with(.,'Et Dieu dist')]/ref/verset/@n 	 3.      return $verset
Le résultat aurait été identique.
L'instruction « Where »inclut une clause restrictive que l'on pourrait gloser par « telle que » : « pour toute numérotation de verset telle que... » et « return » interrompt la boucle et met fin au traitement des fonctions. L'ensemble obéit également au formalisme XML, ce en quoi Xquery n'est pas simplement un langage de requête comme MySQL, mais bien un langage de transformation :
	1. <Bible_nouvelle> 	2.    { 	3. 	for $verset at $compte  	4.       in /Bible/paragraphe  	5.		return  	6.		  <verset_n n=‘{$compte}’ >{data($verset)}</verset_n>	    	    7.    }	 	8. </Bible_nouvelle>
En l'occurrence, les accolades permettent de désambiguïser la requête et d'indiquer au processeur que le texte inclus est une requête et pas un simple texte. Dans la boucle « for (l.3) », on demande au processeur de parcourir l'ensemble des nœuds « paragraphe » de la base et à chaque occurrence de renvoyer le contenu de la donnée sans le balisage grâce à la fonction ‘data() (l.6)’ et d'imbriquer l'ensemble dans un nouveau champ de base nommé <verset_n> dont l’attribut est le rang d’apparition (« $compte »). 
Xquery est un langage de requête de haut niveau particulièrement adapté à l'exploitation des données textuelles structurées sous forme d'arborescences XML. Au même titre qu'XSLT, c'est un outil de transformation des schémas XML, mais les récents développements des préconisations du W3C qui ont conduit à la publication d'Xquery 3.0 orientent résolument ce dernier vers le domaine de la programmation. L'ensemble des bibliothèques de recherches « plein texte » (Full-Text) le rendent donc particulièrement docile à la manipulation par des linguistes et l'existence d'une synonymie propre aux requêtages dans le domaine permettent d'aborder avec une grande souplesse des formules complexes. Ainsi, à partir d'une arborescence comme celle précédemment décrite, il est possible d'extraire les données de manière dynamique selon des voies différentes mais qui sont sémantiquement interprétées de manière identique. Ainsi, une expression telle que :
1. for $x in //titre[@id='glose'][./text() contains text 'ceste' using 			stemming]  2.   		return $x  3.(: Pour tout titre du corpus dont l'id indique qu'il s'agit d'un titre de la glose, affiche l'ensemble des titres concernés si et seulement si ils contiennent le mot « ceste » au singulier comme au pluriel :)
se lit exactement de la même manière que :
1. for $x in //titre where $x/@id='glose'  2.  return for $p in $x where $p contains text 'ceste' using stemming  3.    return $p
ou bien encore :
1. //titre[@id=‘glose'][matches(./text(), 'ceste')][matches(./text(), 'cestes')]
Soit:
2. //titre[@id=‘glose’][. contains text ‘ceste’ using stemming]
La grande liberté syntaxique accordée au développeur et les temps de traitement extrêmement rapides des bases XML en font un outil parfait pour la restitution des données de l'arbre des manuscrits. L'adaptation des fonctions « plein texte » dans le logiciel BaseX autorisent également des extractions rapides grâce à la mise en oeuvre d’instructions propres à la base particulièrement adaptées au développement d'applications WEB comme c'est le cas dans le projet Corpus Bible Historiale qui existe en collaboration avec l'Université Princeton et dont Biblehistoriale.fr est un maillon actif. L'instruction extract permet par exemple d'appliquer un style au vol sur les résultats d'une requête de manière pertinente :
1. for $i in //div[./text() contains text "Dieu" using stemming using fuzzy] 2.	 return  3.	  <p>{ft :extract($i[text() contains text "Dieu"], "yellow", 26)}</p>
Malgré l'apparente simplicité de la syntaxe Xquery, il est possible de construire des requêtes complexes sur de grands ensembles. Voilà par exemple comment extraire du corpus très simplement le texte de la traduction expurgée des commentaires de la glose :
 1.	<corpus id='Bible'>  2.	       {  3.	          let $index := for $x in //titre[@id='historia'] return $x  4.	          return  5.	          for $a in $index return   6.	          <chapitre>  7.	              <titre>  8.	                  {data($a)}  9.	             </titre>  10.	           <texte>  11.	               {($a/following-sibling ::*[1])}  12.	          </texte>  13.	      </chapitre>  14.	      }  15.	</corpus>
Et le résultat pour les premiers versets de l'Exode :
 1.	<corpus id="Bible">  2.	  <chapitre>  3.	    <titre>Du servage les fils Israel selonc la Bible</titre>  4.	    <texte>  5.	      <texte id="Bible">  6.	        <localisation>  7.	          <livre>1</livre>  8.	          <verset>1</verset>  9.	        </localisation>Ce sont li non des fils Israel qui entrerent en egypte avec Jacob. Et y entra Chascuns avec la maisnie<localisation>  10.	          <livre>1</livre>  11.	          <verset>2</verset>  12.	        </localisation>Ruben Symeon Lea Judas<localisation>  13.	          <livre>1</livre>  14.	          <verset>3</verset>  15.	        </localisation>Ysachar Zabulon Benyamin<localisation>  16.	          <livre>1</livre>  17.	          <verset>4</verset>  18.	        </localisation>Dan Heptalim Gad Asser.<localisation>  19.	  </chapitre>  20.	</corpus>
L’ensemble de ce dernier paragraphe peut très facilement au vol être transformé en XML/TEI afin de produire un affichage intégré dans une perspective de collaboration de recherches, et se voir appliquer un style CSS dynamique.
ISILEX
Isilex est un outil simple, qui est à la fois un serveur Web basé sur Basex, un CMS et un gestionnaire de contenus collaboratifs XML/XQuery permettant la construction d’encyclopédies, la mise en ligne de corpus et le croisement automatique des données grâce à un serveur Rest et à un ensemble de fonctions XQuery livrées avec le logiciel.

Isilex étant basé sur un moteur JAVA, il est exploitable sur n’importe quelle plateforme. Il suffit de lancer l’exécutable pour disposer d’un serveur Web, d’une interface d’édition de données au format XML et d’un outil d’édition de contenus en lignes (pages du site et base de données de recherches).
Une fois déployé, Isilex eut très facilement être modifié pour intégrer de nouvelles applications, c’est-à-dire de nouvelles URL associées à de nouvelles fonctions. Pour ce faire, il suffit d’éditer un document XQM du répertoire /webapp et d’ajouter sa propre fonction. Isilex met enfin à la disposition du chercheur une petite collection de fonctions issues de sa propre bibliothèque:
- isi:template($contenu) permet de créer automatiquement un affichage au format CSS du site incluant toutes les bibliothèques nécessaires.
isi:lang-text($text) permet de renvoyer un $text dans la langue du site (français ou anglais par défaut) pour peu que $text existe dans le tableau de configuration du site.
isi:validateXML($fiche) permet de tester et de récupérer les erreurs d’une fiche XML ($fiche) au regard du schéma de contrainte défini dans la  base XSD.
A partir de cet ensemble, il est très facile de produire un ensemble d’applications telles que celles qui sont actuellement exploitées par les différents chercheurs qui ont trouvé en Isilex le moyen de publier rapidement des données collaboratives en ligne dans des formats qui respectent les standards de la recherche. 
Conclusion
Dans le contexte général des Humanités Numériques telles qu’elles sont définies dans le projet « Sciences du Texte et Connaissances nouvelles », Isilex propose d’être une solution innovante au service de la Recherche qui mette en valeur une philosophie du WEB (Rest / XQuery) adaptée aux besoins de l’archéologie textuelle et de la mise en valeur des innovations dans nos disciplines. Au delà de l’outil, qui reste un obstacle majeur au démarrage de la recherche en LSHS, il est important de définir un cadre nouveau au sein duquel les chercheurs, philologues, linguistes, littéraires, géographes, juristes, spécialistes des sciences de la communication ou du management se saisissent de la question de la ressource qui reste et demeure l’enjeu primordial du progrès et de la découverte. L’architecture documentaire laissant progressivement place à de nouvelles donnes autour de l’information, de la communication et de la donnée, un CMS XML de cette nature accessible permettrait à court terme d’homogénéiser la structure des données, de faciliter l’interopérabilité des bases et les échanges entre communautés.

Bibliographie

Berners Lee T. (June 1994), Universal Resource Identifiers in WWW, www. w3. org/Addressing/ rfc1630. txt
Berners-Lee, T. (1994), World Wide Web future directions. Plenary Talk. http://www.w3.org/Talks/WWW94Tim/ 
Berners-Lee, T. (1998), Cool URIs don’t change. http://www.w3.org/Provider/Style/URI
Broudoux E., Scopsi C. (2012), « L’enjeu des métadonnées dans un contexte de ”redocumentarisation” », Etudes de communication, Université Lille-3, pp.9-22.
Cotte D. (2013), « Qui (re)travaillera la donnée ? », Documentaliste-Sciences de l’Information (Vol. 50), 3, p. 24-25.
Cotte D. (2011), « Les nouvelles perspectives du web sémantique pour les professionnels de l’information » in Sylvie Dalbin et al., « Approches documentaires : priorité aux contenus », Documentaliste-Sciences de l'Information 2011/4 (Vol. 48), p. 42-59.
Fielding Roy T. (2008), REST APIs must be hypertext-driven, Thèse en Philosophy in Information and Computer Science de l’Université de Californie (Irvine)
Fondin H., (éd) (1991), Bibliographie sur l'informatique documentaire : outils, méthodes, applications, Centre de documentation de l’École internationale de Bordeaux.
Gandon F., Corby O., Faron-Zucker C. (2012), Le web sémantique: Comment lier les données et les schémas sur le web ?, Paris, Dunod.
Monnin A. (2013), Vers une philosophie du Web : le Web comme devenir-artefact de la philosophie (entre URIs, tags, ontologie (s) et ressources), Thèse, Paris 1
SALVADOR X.-L. (2) (2017), Etymologie et archéologie du sens à traver le livre de l’Exode de la Bible Historiale, ZETA Books.
SALVADOR X.-L. (1) (2017),  « « Indexer des documents « du dedans » : quels moyens de répondre à la question du lieu de la donnée (XML, OWL, RDF, REST) ? », Communication, 06/2017
Salvador X.-L. (2016), XML pour les linguistes (avec une préface d’Henri Portine), Paris, L’Harmattan, « Humanités numériques ».


￼	Voici la version de la Vulgate: « tulitque decem camelos de grege domini sui et abiit ex omnibus bonis eius portans secum profectusque perrexit Mesapotamiam ad urbem Nahor » (« il prit dix chameaux du troupeau de son maître et s’en alla emportant tous les biens de son maître avec lui jusqu’à Nahor, en Mésopotamie » ) (SALVADOR (2), 2017, p. 35).￼ pp. 38-39.￼ 8 bits composant une information. Un octet code virtuellement 28 atomes différents résultant de la sérialisation des données.￼ Il s’agit de l’ensemble des moyens de localiser et, en même temps, de consulter une donnée documentaire pertinente dont la consultation répond à la question posée par le lecteur. Sur ce sujet, voir notamment SALVADOR (2), 2017.￼ https://www.w3.org/TR/xquery-30/￼ Les fonctions Ful-Text telles que « stemming », « fuzzy » (pour la distance de Levenshtein), « wildcards » permettent d’appliquer des fonctions de calculs de similarités en même temps que d’imposer un fenêtrage (« in window X words »)  ou des réseaux de synonymie (« using thesaurus X at »). Le stemmer de Basex, c’est-à-dire la ressource de calculs de variations morphologiques, est hérité du stemmer en SnowBall de Lucene.